#ifndef ALM_CAMERA_H
#define ALM_CAMERA_H
#include <math.h>
#include <algorithm>
#include <iostream>
#include "glm/vec3.hpp"
#include "glm/vec4.hpp"
#include "glm/mat4x4.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/quaternion.hpp"


#define INITIAL_NEAR_PLANE 0.1f
#define INITIAL_FAR_PLANE 100.0f
#define INITIAL_FOV_RADIANS ((float)M_PI_4)
#define INITIAL_FORWARD_MOVEMENT_SCALAR 10.0f
#define INITIAL_SIDEWAYS_MOVEMENT_SCALAR 10.0f
#define INITIAL_FOV_SCALAR 2.0f
#define INITIAL_MOUSE_SENSITIVITY_SCALAR 0.005f

class Camera
{
public:
    Camera(float aspect);
    void updateOrientation(double mouseX, double mouseY);
    void updateFOV(double scrollDirection);
    void rebuildView();
    void rebuildPerspective();

    void setFOV(float FOV);//radians
    void setNear(float near);
    void setFar(float far);
    void setAspect(float aspect);

    glm::mat4& getProj();
    glm::mat4& getView(); 
    float getFOV();

    void moveStraight(float direction, float dt);
    void moveSideways(float direction, float dt);

private:
    float mNear, mFar, mFOV, mAspect;
    float mPitch, mYaw;
    float mForwardMovementScalar, mSidewaysMovementScalar, mMouseSensitivityScalar;
    double mPrevMouseX, mPrevMouseY;
    glm::vec3 mEye; 
    const static glm::vec3 UP, RIGHT;
    const static float MAX_FOV_RADIANS, MIN_FOV_RADIANS;

    glm::mat4 mProj, mView; 
 
};

inline Camera::Camera(float aspect): mNear(INITIAL_NEAR_PLANE), mFar(INITIAL_FAR_PLANE), 
mFOV(INITIAL_FOV_RADIANS), mAspect(aspect), 
mPitch(0.0f), mYaw(0.0f),
mForwardMovementScalar(INITIAL_FORWARD_MOVEMENT_SCALAR), mSidewaysMovementScalar(INITIAL_SIDEWAYS_MOVEMENT_SCALAR), mMouseSensitivityScalar(INITIAL_MOUSE_SENSITIVITY_SCALAR),mEye(0.0f, 0.0f, 4.0f) 
{
    rebuildView();
    rebuildPerspective();
}

inline float Camera::getFOV()
{
    return mFOV;
}

inline glm::mat4& Camera::getProj()
{
    return mProj;
}

inline glm::mat4& Camera::getView()
{
    return mView;
}

inline void Camera::setAspect(float aspect)
{
    mAspect = aspect;
}

#endif
